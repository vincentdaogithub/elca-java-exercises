{"ast":null,"code":"import { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function bufferTime(bufferTimeSpan, ...otherArgs) {\n  var _a, _b;\n  const scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\n  const bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  const maxBufferSize = otherArgs[1] || Infinity;\n  return operate((source, subscriber) => {\n    let bufferRecords = [];\n    let restartOnEmit = false;\n    const emit = record => {\n      const {\n        buffer,\n        subs\n      } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer = [];\n        const record = {\n          buffer,\n          subs\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n    startBuffer();\n    const bufferTimeSubscriber = createOperatorSubscriber(subscriber, value => {\n      const recordsCopy = bufferRecords.slice();\n      for (const record of recordsCopy) {\n        const {\n          buffer\n        } = record;\n        buffer.push(value);\n        maxBufferSize <= buffer.length && emit(record);\n      }\n    }, () => {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, () => bufferRecords = null);\n    source.subscribe(bufferTimeSubscriber);\n  });\n}","map":{"version":3,"names":["Subscription","operate","createOperatorSubscriber","arrRemove","asyncScheduler","popScheduler","executeSchedule","bufferTime","bufferTimeSpan","otherArgs","scheduler","_a","bufferCreationInterval","_b","maxBufferSize","Infinity","source","subscriber","bufferRecords","restartOnEmit","emit","record","buffer","subs","unsubscribe","next","startBuffer","add","push","bufferTimeSubscriber","value","recordsCopy","slice","length","shift","complete","undefined","subscribe"],"sources":["D:\\ELCA_Bootcamp\\Pilot_Projects\\elca-java-exercises\\pim-tool-front\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts"],"sourcesContent":["import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}